<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Jos(1): Bootloader · 4buf</title><meta name="description" content="Jos(1): Bootloader - 4buf"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://4buf.com/atom.xml" title="4buf"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="4buf" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/4buf" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Jos(1): Bootloader</h1><div class="post-info">Mar 17, 2021</div><div class="post-content"><p>脚本分为 <code>boot.S</code>/<code>loader.c</code>/<code>Makefile</code>，Makefile 负责将其余两个脚本编译为 bootloader，它的职责很简单：</p>
<ul>
<li>boot 负责初始化</li>
<li>loader 负责把 kernel 从磁盘上加载到内存</li>
</ul>
<h1 id="Genesis"><a href="#Genesis" class="headerlink" title="Genesis"></a>Genesis</h1><h2 id="boot-S"><a href="#boot-S" class="headerlink" title="boot.S"></a>boot.S</h2><p>AT&amp;T 风格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">    .code16</span><br><span class="line">    cli</span><br><span class="line">    cld</span><br><span class="line">    </span><br><span class="line">    xorw %ax,%ax</span><br><span class="line">    movw %ax,%ds</span><br><span class="line">    movw %ax,%es</span><br><span class="line">    movw %ax,%gs</span><br><span class="line">    movw %ax,%fs</span><br><span class="line">    movw %ax,%ss</span><br><span class="line"></span><br><span class="line">seta20.1:</span><br><span class="line">    inb     $0x64,%al</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.1</span><br><span class="line">    </span><br><span class="line">    movb    $0xd1,%al</span><br><span class="line">    outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb     $0x64,%al</span><br><span class="line">    testb   $0x2,%al</span><br><span class="line">    jnz     seta20.2</span><br><span class="line">    </span><br><span class="line">    movb    $0xdf,%al</span><br><span class="line">    outb    %al,$0x60</span><br><span class="line">    </span><br><span class="line">    lgdt    gdtdesc</span><br><span class="line">    movl    %cr0, %eax</span><br><span class="line">    orl     $0x1, %eax</span><br><span class="line">    movl    %eax, %cr0</span><br><span class="line">    </span><br><span class="line">    ljmp    $0x8, $protcseg</span><br><span class="line">    </span><br><span class="line">    .code32</span><br><span class="line">protcseg:</span><br><span class="line">    movw    $0x10, %ax</span><br><span class="line">    movw    %ax, %ds</span><br><span class="line">    movw    %ax, %es</span><br><span class="line">    movw    %ax, %fs</span><br><span class="line">    movw    %ax, %gs</span><br><span class="line">    movw    %ax, %ss</span><br><span class="line">    </span><br><span class="line">    movl    $start, %esp</span><br><span class="line">    call    load</span><br><span class="line"></span><br><span class="line">spin:</span><br><span class="line">    jmp	spin</span><br><span class="line"></span><br><span class="line">gdt:</span><br><span class="line">    # null seg</span><br><span class="line">    .long 0x0, 0x0</span><br><span class="line">    </span><br><span class="line">    # code seg</span><br><span class="line">    .word 0xffff        # Segment Limit 15:00</span><br><span class="line">    .word 0x0           # Base Address 15:00</span><br><span class="line">    .byte 0x0           # Base 23:16</span><br><span class="line">    .byte 0b10011010    # P&#x3D;1, DPL&#x3D;0, S&#x3D;1, Type&#x3D;1010&#x3D;Execute&#x2F;Read</span><br><span class="line">    .byte 0b11001111    # G&#x3D;1, D&#x2F;B&#x3D;1, L&#x3D;0, AVL&#x3D;0, Seg.Limit.19:16</span><br><span class="line">    .byte 0x0           # Base 31:24</span><br><span class="line">    </span><br><span class="line">    # data seg</span><br><span class="line">    .word 0xffff        # Segment Limit 15:00</span><br><span class="line">    .word 0x0           # Base Address 15:00</span><br><span class="line">    .byte 0x0           # Base 23:16</span><br><span class="line">    .byte 0b10010010    # P&#x3D;1, DPL&#x3D;0, S&#x3D;1, Type&#x3D;0010&#x3D;Read&#x2F;Write</span><br><span class="line">    .byte 0b11001111    # G&#x3D;1, D&#x2F;B&#x3D;1, L&#x3D;0, AVL&#x3D;0, Seg.Limit.19:16</span><br><span class="line">    .byte 0x0           # Base 31:24</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word   0x17</span><br><span class="line">    .long   gdt</span><br></pre></td></tr></table></figure>

<p>boot 有几步：</p>
<ol>
<li>清空数据段寄存器（bios 引导完 cs:ip = 0x7c00，所以 cs 不需要设置）</li>
<li>开启 A20 line</li>
<li>加载 GDT</li>
<li>开启 CR0.PE</li>
<li>设置段选择子并跳到 loader.c 中的入口</li>
</ol>
<p><strong>1. 清空段寄存器</strong></p>
<p>实模式下寻址方式为 <code>段基址 &lt;&lt; 4 + 偏移量</code>，即 16-bit 凑出 20-bit（涉及历史原因），所以清空段寄存器使得 offset = PA。</p>
<p><strong>2. 开启 A20 line</strong></p>
<p>A20 参考（其实就是键盘控制器和 A20 引脚的与门）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.independent-software.com/operating-system-development-enabling-a20-line.html">ENABLING THE A20 LINE</a></li>
<li><a target="_blank" rel="noopener" href="https://www.win.tue.nl/~aeb/linux/kbd/A20.html">A20 - a pain from the past</a></li>
<li><a target="_blank" rel="noopener" href="https://bochs.sourceforge.io/techspec/PORTS.LST">XT, AT and PS/2 I/O port addresses</a></li>
</ul>
<p><strong>3. 加载 GDT</strong></p>
<p>不同于 8086 实模式，32-bit 保护模式下 offset 已经有 32 位了，理论上我们可以这么玩：Offset = Logical-Address = Linear-Address = Physical-Address，但是 x86 的架构导致我们并不能限制段寄存器参与寻址，既然得带着它玩，那如果不开启分页单纯分段寻址，让段寄存器去切 4G 内存显然也不合理，毕竟它还是 16-bit 也切不到那么高的地方，这个时候就得想办法把 Segment-Base-Address 长度扩一点，那明显只有放内存里了，于时：</p>
<ul>
<li>段基址在 GDT 中放到内存，GDT 是一张表，每个段寄存器可以指定使用其中一项，段寄存器中类似索引功能的值就被称为 <code>Segment Selector</code>，而 GDT 中的每一项称为 <code>Segment Descriptor</code></li>
<li>CPU 也需要知道 GDT 在哪/有多大，这个值被放到了 GDTR 寄存器</li>
</ul>
<p>GDT 的格式参考 <a target="_blank" rel="noopener" href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">Intel 手册</a> 如下：</p>
<p><img src="/images/jos-bootloader/segment_descriptor.png"></p>
<p><code>boot.S</code> 中将 6.828 原先的 SEG_NULL/SEG 方法替换成了手写，请注意 x86 默认是 Little-Endian 小端序，想象一下代码是从上到下被放到内存从低到高（<code>.word</code>/<code>.byte</code> 左高位右低位），再对比 Segment Descriptor 从右到左可以很直观的看到具体的定义。</p>
<p>可以看到我们虽然使用了分段，但实际上为了将来的分页，这里的分段特性是期望尽可能 “抹除” 的，<strong>毕竟分段是 x86 的特性，而分页才是现代 OS 的共性</strong>。默认约定 GDT 第一个 Descriptor 为空段，所以要让分段透明，至少需要 null/code/data 三个段，而为了简单起见（毕竟进了 kernel 的逻辑就开启分页了，也就为了 <code>loader.c</code> 执行这么一会），所以代码和数据段都映射到了整段内存。</p>
<p>定义好 GDT 之后需要通过 <code>lgdt</code> 设置 GDTR 寄存器的值（也就是代码中 <code>gdtdesc</code> 的值），需要注意的是 <code>limit = (segment-descriptor = 64-bit = 8-byte) * 3 - 1 = 23 = 0x17</code>（减 1 是约定）：</p>
<p><img src="/images/jos-bootloader/gdtr.png"></p>
<p><strong>4. 开启 CR0.PE</strong></p>
<p>参考 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Control_register#CR0">Control register</a>，这里通过 eax 保留了 CR0 除 PE 位之外其余位原本的值并将 PE 位置为 1。</p>
<p><strong>5. 设置段选择子并跳到 loader.c 中的入口</strong></p>
<p>在设置段寄存器时，Segment Selector 格式如下：</p>
<p><img src="/images/jos-bootloader/segment_selector.png"></p>
<p>可以看到代码段选择子为 <code>0x8</code>，其余为 <code>0x10</code>，段寄存器的赋值方式为：</p>
<ul>
<li> Direct load instructions such as the MOV, POP, LDS, LES, LSS, LGS, and LFS instructions. These instructions explicitly reference the segment registers.</li>
<li> Implied load instructions such as the far pointer versions of the CALL, JMP, and RET instructions, the SYSENTER and SYSEXIT instructions, and the IRET, INT n, INTO, INT3, and INT1 instructions. <strong>These instructions change the contents of the CS register</strong> (and sometimes other segment registers) as an incidental part of their operation.</li>
</ul>
<p>最终在 call loader 之前，因为需要执行 C，所以需要设置栈，ss 已经设置过了，esp = $start 的地址即栈实际上是在 bootloader 这段代码前面的，也就是 0x7c00 前面往低地址增长。</p>
<h2 id="loader-c"><a href="#loader-c" class="headerlink" title="loader.c"></a>loader.c</h2><p>暂且简单，后面再补充：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void load(void) &#123;</span><br><span class="line">	while (1) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>此时目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- bootloader&#x2F;</span><br><span class="line">    - boot.S</span><br><span class="line">    - loader.c</span><br><span class="line">    - sign.pl</span><br><span class="line">- Makefile</span><br></pre></td></tr></table></figure>

<p><code>sign.pl</code> 是原封不动的用的 6.828 的 perl 脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;perl</span><br><span class="line"></span><br><span class="line">open(BB, $ARGV[0]) || die &quot;open $ARGV[0]: $!&quot;;</span><br><span class="line"></span><br><span class="line">binmode BB;</span><br><span class="line">my $buf;</span><br><span class="line">read(BB, $buf, 1000);</span><br><span class="line">$n &#x3D; length($buf);</span><br><span class="line"></span><br><span class="line">if($n &gt; 510)&#123;</span><br><span class="line">	print STDERR &quot;boot block too large: $n bytes (max 510)\n&quot;;</span><br><span class="line">	exit 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print STDERR &quot;boot block is $n bytes (max 510)\n&quot;;</span><br><span class="line"></span><br><span class="line">$buf .&#x3D; &quot;\0&quot; x (510-$n);</span><br><span class="line">$buf .&#x3D; &quot;\x55\xAA&quot;;</span><br><span class="line"></span><br><span class="line">open(BB, &quot;&gt;$ARGV[0]&quot;) || die &quot;open &gt;$ARGV[0]: $!&quot;;</span><br><span class="line">binmode BB;</span><br><span class="line">print BB $buf;</span><br><span class="line">close BB;</span><br></pre></td></tr></table></figure>

<p><code>Makefile</code> 使用标准的 <a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html">GNU make</a> 语法，尽量没用变量和拼接，虽然 lowb 但是读起来更方便：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># all</span><br><span class="line">all: build&#x2F;bootloader build&#x2F;bootloader&#x2F;bootloader.bin</span><br><span class="line"></span><br><span class="line"># dirs for build</span><br><span class="line">build&#x2F;bootloader:</span><br><span class="line">	mkdir -p build&#x2F;bootloader</span><br><span class="line"></span><br><span class="line"># build bootloader</span><br><span class="line">build&#x2F;bootloader&#x2F;bootloader.bin: build&#x2F;bootloader&#x2F;bootloader.tmp</span><br><span class="line">	objcopy -S -O binary -j .text $&lt; $@</span><br><span class="line">	chmod 755 build&#x2F;bootloader&#x2F;bootloader.bin</span><br><span class="line">	perl bootloader&#x2F;sign.pl build&#x2F;bootloader&#x2F;bootloader.bin</span><br><span class="line">build&#x2F;bootloader&#x2F;bootloader.tmp: build&#x2F;bootloader&#x2F;boot.o build&#x2F;bootloader&#x2F;loader.o</span><br><span class="line">	ld -N -m elf_i386 -e start -Ttext 0x7C00 $^ -o $@</span><br><span class="line">build&#x2F;bootloader&#x2F;boot.o: bootloader&#x2F;boot.S</span><br><span class="line">	as --32 -march&#x3D;i386 $&lt; -o $@</span><br><span class="line">build&#x2F;bootloader&#x2F;loader.o: bootloader&#x2F;loader.c</span><br><span class="line">	gcc -std&#x3D;gnu99 -m32 -static -nostdinc \</span><br><span class="line">		-Wall -Wno-format -Wno-unused -Werror \</span><br><span class="line">		-fno-builtin -fno-omit-frame-pointer -fno-tree-ch -fno-stack-protector \</span><br><span class="line">		-Os -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line"># clean</span><br><span class="line">clean:</span><br><span class="line">	rm -r build</span><br></pre></td></tr></table></figure>

<p>核心思想就是：</p>
<ol>
<li>将 <code>boot.S</code> 编译为 <code>boot.o</code></li>
<li>将 <code>loader.c</code> 编译为 <code>loader.o</code></li>
<li>将 <code>boot.o</code> 和 <code>loader.o</code> 链接为 <code>bootloader.tmp</code>，链接后的入口为 <code>start</code>，.text section 起始地址为 <code>0x7c00</code></li>
<li><code>bootloader.tmp</code> 已经是标准的 executable ELF binary，但现阶段一切还是 “裸跑” 的，ELF 对于我们来说并没有意义，需要把 .text section 给 copy 出来，再使用 <code>sign.pl</code> 稍微修改下使其满足 MBR 的要求，最终产物即 <code>bootloader.bin</code></li>
</ol>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p><a target="_blank" rel="noopener" href="https://www.qemu.org/">QEMU</a> 可以不用编译全部 arch 否则会非常慢，但一定要包含 i386，<code>qemu-system-i386 -S -s -hda bootloader.bin -nographic</code> 将 bootloader 读到启动盘，新开 tty 使用 gdb <code>target remote :1234</code> 交互 debug，断点打到 <code>0x7c00</code> 可以看到 SeaBIOS “Booting from Hard Disk..” 的提示：</p>
<p><img src="/images/jos-bootloader/booting.png"></p>
<p>gdb 侧使用 <code>set disassemble-next-line on</code> 配合 <code>si</code> 单步调试可以看到下一行将要执行的代码：</p>
<p><img src="/images/jos-bootloader/si.png"></p>
<p>接着有个小技巧，gdb 默认的 <code>info registers</code> 其实是不全的，我们可以进 <a target="_blank" rel="noopener" href="https://qemu.readthedocs.io/en/latest/system/monitor.html">QEMU Monitor</a>，这个按键比较刁钻，<code>CTRL+A C</code> 的意思是先同时按住 <code>CTRL</code> 和 <code>A</code>，松开后再按 <code>C</code>，成功进入的话效果是这样：</p>
<p><img src="/images/jos-bootloader/qemu_monitor.png"></p>
<p><code>si</code> 一直到 <code>lgdt</code> 之后看下 GDTR 里边是啥（不用纠结于 gdb opcode 转 asm 为什么是 32-bit，因为它 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32955887/how-to-disassemble-16-bit-x86-boot-sector-code-in-gdb-with-x-i-pc-it-gets-tr">不支持 16-bit</a>）：</p>
<p><img src="/images/jos-bootloader/ir_gdt.png"></p>
<p>前面提到过 GDTR 的格式，可以很容易的看出来 Linear-Base-Address = 0x7c50 / Table-Limit = 0x17，也就是说 GDT 在内存 <code>0x7c50</code> 这里，用 <a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_24256693/article/details/47298513">gdb x</a> 看看长啥样：</p>
<p><img src="/images/jos-bootloader/mem_gdt.png"></p>
<p>继续 debug 可以看到 CR0.PE 位被开启：</p>
<p><img src="/images/jos-bootloader/pe.png"></p>
<p>一直到 <code>ljmp</code> 结束，我们才真正进入保护模式也就是 32-bit 环境下运行：</p>
<p><img src="/images/jos-bootloader/32_registers.png"></p>
<p>注意观察几个段寄存器值的变化，这其中有个比较有意思的地方，我们知道寻址时 CPU 先看段寄存器接着去找 GDTR 定位 GDT 是要经历一次内存寻址的，为了加快速度，Selector 指向的 Descriptor 会被 “缓存” 到段寄存器的 Hidden-Part 部分：</p>
<p><img src="/images/jos-bootloader/sr_hidden_part.png"></p>
<p>大概长这样：</p>
<p><img src="/images/jos-bootloader/sr_hidden_part_desc.png"></p>
<p>对比这个看的更明显：</p>
<p><img src="/images/jos-bootloader/mem_gdt_h.png"></p>
<p>在进 <code>load()</code> 方法之前再看一下栈指针：</p>
<p><img src="/images/jos-bootloader/c_esp.png"></p>
<p>最终进入循环：</p>
<p><img src="/images/jos-bootloader/load_loop.png"></p>
<p>// TODO</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/03/18/jos-2-kernel-init/" class="prev">PREV</a></div><div class="copyright"><p>© 2015 - 2021 <a href="http://4buf.com">4buf</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p><p>友情链接：<a href="http://ghost.davidxu5945.com/" target="_blank">阿西的博客</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>